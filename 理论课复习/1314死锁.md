# 进程同步



## 目录

```
死锁概念
处理思索的基本方法
——鸵鸟算法
——死锁检测
——死锁预防
——死锁避免
```



## 索引与重点

### 概念

死锁定义P50：一个进程集合中的每个进程都在等待只能由该进程集合中其他进程才能引发的事件

发生原因：竞争资源、并发执行顺序不当

临时性资源：消息、中断等，属于不可剥夺资源

例如：汇合时先wait再signal、生产者消费者丢失sleep、互斥访问mutex在P(mutex)前

**死锁发生必要条件**：互斥、保持和请求、不可剥夺、环路等待

### 处理死锁方法

鸵鸟算法：无视死锁，发生概率小、影响小时可采用

死锁检测：允许死锁，采取措施检测恢复（资源分配图、资源向量计算）

死锁预防：破坏四个条件之一

死锁避免：资源分配前判断是否安全，需要执行前获取额外信息，如银行家算法（知道进程所需资源最大值）

### 死锁检测与恢复

检查是否存在循环等待

**资源分配图**P4：每类资源一个死锁检测，观察是否存在环

资源=>进程：资源占用

进程=>资源：请求资源

**资源向量算法**P7

死锁恢复P11：资源抢占、杀死进程、回滚法

### 死锁预防

打破四个条件之一P15

### 哲学家进餐问题

至多允许四人进餐：破除循环等待

奇数号先拿左偶数号先拿右：破除循环等待

编号从低到高拿筷子：破除循环等待

同时拿起两根筷子：破除保持请求

Tanebaum算法P34：破除死锁但仍会导致饥饿

### 死锁避免

死锁预防是静态策略，死锁避免是动态策略P40，分配时动态检查

假设：事先知道请求的所有资源

安全序列P41、安全状态P42：不安全状态不一定死锁，死锁一定是不安全状态

### 银行家算法

假设P45

Need(i,j)= Max(i,j)-Allocation(i,j) 

每次分配后进行安全性检查

举例P53

允许互斥、部分分配、不可抢占，但要求说明最大分配

死锁定理P56：死锁<=>某时刻资源分配图不可完全化简（不能消去所有边转化为结点全部孤立）



## 小测题

一个进程不可能死锁